<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WhatIsBlockchainDoing.com</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; overflow: hidden; }
  canvas { display: block; }

  #header {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 32px;
    background: #111;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 12px;
    z-index: 5;
    border-bottom: 1px solid #222;
  }

  #header .site-name {
    color: #888;
    font: 12px monospace;
    user-select: none;
  }

  #header .chain-buttons {
    display: flex;
    gap: 4px;
  }

  #header .chain-btn {
    background: none;
    border: none;
    border-bottom: 2px solid transparent;
    color: #666;
    font: 12px monospace;
    padding: 4px 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: color 0.15s, border-color 0.15s;
  }

  #header .chain-btn:hover {
    color: #aaa;
  }

  #header .chain-btn.active {
    color: #ccc;
    border-bottom-color: #ccc;
  }

  #header .chain-btn .dot {
    width: 4px;
    height: 4px;
    border-radius: 1px;
    background: #333;
    transition: background 0.2s;
    flex-shrink: 0;
  }

  #tooltip {
    display: none;
    position: fixed;
    background: #0d0d0d;
    border: 1px solid #2a2a2a;
    color: #ccc;
    font-family: monospace;
    z-index: 10;
    pointer-events: none;
    width: 395px;
    max-width: 90vw;
  }
  #tooltip a {
    color: #6cf;
    text-decoration: none;
    pointer-events: auto;
  }
  #tooltip a:hover { text-decoration: underline; }
  .tt-upper {
    display: flex;
    align-items: stretch;
    padding: 14px 0;
    gap: 0;
  }
  .tt-col {
    width: 33.33%;
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 0 8px;
    box-sizing: border-box;
  }
  .tt-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    gap: 6px;
    min-width: 0;
    overflow: hidden;
  }
  .tt-bar {
    flex-shrink: 0;
    border-radius: 1px;
    image-rendering: pixelated;
  }
  .tt-item { text-align: center; }
  .tt-value {
    font-size: 13px;
    color: #ddd;
    white-space: nowrap;
    line-height: 1.2;
  }
  .tt-label {
    font-size: 8px;
    color: #444;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    line-height: 1;
    margin-top: 1px;
  }
  .tt-spacer { flex: 1; }
  .tt-bottom {
    border-top: 1px solid #1a1a1a;
    padding: 8px 16px;
    display: flex;
    flex-direction: column;
    gap: 5px;
  }
  .tt-addr-row {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .tt-addr-pattern {
    flex-shrink: 0;
    image-rendering: pixelated;
  }
  .tt-addr {
    font-size: 10px;
    color: #666;
    flex: 1;
  }
  .tt-addr-label {
    font-size: 8px;
    color: #444;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    flex-shrink: 0;
    width: 28px;
    text-align: right;
  }
  .tt-hash-bar {
    border-top: 1px solid #181818;
    padding: 5px 16px 6px;
    background: #0a0a0a;
  }
  .tt-hash-bar a {
    font-size: 9px;
    color: #444;
    word-break: break-all;
    display: block;
    line-height: 1.3;
  }
</style>
</head>
<body>
<div id="header">
  <span class="site-name">WhatIsBlockchainDoing.com</span>
  <div class="chain-buttons">
    <button class="chain-btn active" data-chain="monad"><span class="dot" id="dot-monad"></span>Monad</button>
    <button class="chain-btn" data-chain="base"><span class="dot" id="dot-base"></span>Base</button>
    <button class="chain-btn" data-chain="ethereum"><span class="dot" id="dot-ethereum"></span>Ethereum</button>
  </div>
</div>
<canvas id="canvas"></canvas>
<div id="tooltip"></div>
<script>

// --- Chain configuration ---

const CHAINS = {
  monad: {
    name: "Monad",
    rpcUrl: "https://rpc-mainnet.monadinfra.com",
    explorerUrl: "https://monadscan.com/tx/",
    explorerName: "Monadscan",
    currency: "MON",
    blockTime: 400,
    pollInterval: 200,
    color: [255, 255, 255],
    tipMin: 0.1,       // gwei — typical floor ~2 gwei
    tipMax: 10000,     // gwei — generous log headroom
    lowTip: 20,        // gwei — threshold for "low priority" tint
  },
  base: {
    name: "Base",
    rpcUrl: "https://base-rpc.publicnode.com",
    explorerUrl: "https://basescan.org/tx/",
    explorerName: "Basescan",
    currency: "ETH",
    blockTime: 2000,
    pollInterval: 1000,
    color: [0, 82, 255],
    tipMin: 0.0001,    // gwei — many Base txs tip sub-0.001 gwei
    tipMax: 100,       // gwei — generous log headroom for L2
    lowTip: 0.005,     // gwei — median tip is ~0.001 gwei
  },
  ethereum: {
    name: "Ethereum",
    rpcUrl: "https://ethereum-rpc.publicnode.com",
    explorerUrl: "https://etherscan.io/tx/",
    explorerName: "Etherscan",
    currency: "ETH",
    blockTime: 12000,
    pollInterval: 6000,
    color: [98, 126, 234],
    tipMin: 0.01,      // gwei — MEV bundles can tip very low
    tipMax: 1000,      // gwei — covers extreme congestion spikes
    lowTip: 1,         // gwei — typical tip is 0.1-2 gwei
  },
};

// --- Constants ---

const HEADER_HEIGHT = 33; // 32px + 1px border
const COL_WIDTH = 4;
const COL_HEIGHT = 134;
const ROW_SPACING = 144;
const BOUNDARY_ROWS = [20, 21, 42, 43, 52, 53, 68, 69, 90, 91, 112, 113];
const BLOCK_GAP = 10;
const FOUR_BYTE_START = 44;
const FOUR_BYTE_END = 51;

// --- DOM refs ---

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const tooltipEl = document.getElementById("tooltip");

// --- State ---

let activeChainKey = "monad";
let cursorX = 0;
let cursorY = 0;
let nextBlockNum = null;
let txHitmap = [];
let blockData = {};
let pollTimeoutId = null;
let tooltipLocked = false;
let lastHit = null;

// Indicator dot intervals for non-selected chains
const dotIntervals = {};
// Track dot flash timeouts
const dotFlashTimeouts = {};

function getActiveChain() {
  return CHAINS[activeChainKey];
}

// --- Clear / reset ---

function clearStoredData() {
  txHitmap = [];
  blockData = {};
  hideTooltip();
}

function resize() {
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth;
  const h = window.innerHeight - HEADER_HEIGHT;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";
  canvas.style.marginTop = HEADER_HEIGHT + "px";
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  cursorX = 0;
  cursorY = 0;
  clearStoredData();
}
window.addEventListener("resize", resize);
resize();

// --- RPC ---

async function rpcCall(method, params) {
  const chain = getActiveChain();
  const res = await fetch(chain.rpcUrl, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params }),
  });
  const json = await res.json();
  if (json.error) throw new Error(json.error.message);
  return json.result;
}

async function getBlockByNumber(blockNum) {
  const hex = "0x" + blockNum.toString(16);
  return rpcCall("eth_getBlockByNumber", [hex, true]);
}

async function getLatestBlockNumber() {
  const block = await rpcCall("eth_blockNumber", []);
  return parseInt(block, 16);
}

// --- Byte extraction helpers ---

function hexToBytes(hex) {
  if (!hex || hex === "0x") return new Uint8Array(0);
  const clean = hex.startsWith("0x") ? hex.slice(2) : hex;
  const bytes = new Uint8Array(clean.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    bytes[i] = parseInt(clean.substr(i * 2, 2), 16);
  }
  return bytes;
}

function addressToBytes(addr) {
  return hexToBytes(addr);
}

// --- Column pixel generation ---

function inputLenExpScale(inputLen, pxCount) {
  const MIN_LEN = 36;
  const MAX_LEN = 100000;
  const arr = new Uint8Array(pxCount);
  if (inputLen < MIN_LEN) return arr;
  const ratio = Math.min(1, Math.log2(inputLen / MIN_LEN) / Math.log2(MAX_LEN / MIN_LEN));
  if (ratio <= 0.5) {
    const halfRatio = ratio / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 128;
  } else {
    for (let i = 0; i < pxCount; i++) arr[i] = 128;
    const halfRatio = (ratio - 0.5) / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 255;
  }
  return arr;
}

function gasExpScale(gasUsed, pxCount) {
  const MIN_GAS = 20000;
  const MAX_GAS = 30000000;
  const arr = new Uint8Array(pxCount);
  if (gasUsed < MIN_GAS) return arr;
  const ratio = Math.min(1, Math.log2(gasUsed / MIN_GAS) / Math.log2(MAX_GAS / MIN_GAS));
  if (ratio <= 0.5) {
    const halfRatio = ratio / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 128;
  } else {
    for (let i = 0; i < pxCount; i++) arr[i] = 128;
    const halfRatio = (ratio - 0.5) / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 255;
  }
  return arr;
}

function priorityFeeExpScale(feeGwei, pxCount, minFee, maxFee) {
  const arr = new Uint8Array(pxCount);
  if (feeGwei < minFee) return arr;
  const ratio = Math.min(1, Math.log2(feeGwei / minFee) / Math.log2(maxFee / minFee));
  if (ratio <= 0.5) {
    const halfRatio = ratio / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 128;
  } else {
    for (let i = 0; i < pxCount; i++) arr[i] = 128;
    const halfRatio = (ratio - 0.5) / 0.5;
    const filled = 1 + Math.round(halfRatio * (pxCount - 1));
    for (let i = pxCount - filled; i < pxCount; i++) arr[i] = 255;
  }
  return arr;
}

function buildColumn(tx, baseFeeWei) {
  const col = new Uint8Array(COL_HEIGHT);

  // 20px sender address (rows 0-19)
  const from = addressToBytes(tx.from);
  col.set(from.slice(0, 20), 0);

  // 20px receiver address (rows 22-41)
  if (tx.to) {
    const to = addressToBytes(tx.to);
    col.set(to.slice(0, 20), 22);
  }

  // Input data
  const input = hexToBytes(tx.input);
  const inputLen = input.length;

  // 8px first four bytes of input data (rows 44-51)
  if (inputLen > 0) {
    const sel = tx.input.slice(0, 10).toLowerCase();
    if (sel === '0xa9059cbb' || sel === '0x23b872dd') {
      input[0] = input[1] = input[2] = input[3] = 0xFF;
    }
    const count = Math.min(4, inputLen);
    for (let i = 0; i < count; i++) {
      col[44 + i * 2] = input[i];
      col[44 + i * 2 + 1] = input[i];
    }
  }

  // 14px last bytes of input data (rows 54-67)
  if (inputLen > 4) {
    const tailStart = Math.max(4, inputLen - 14);
    const tail = input.slice(tailStart, inputLen);
    const offset = 54 + (14 - tail.length);
    col.set(tail, offset);
  }

  // 20px input data length (rows 70-89)
  const inputLenScale = inputLenExpScale(inputLen, 20);
  col.set(inputLenScale, 70);

  // 20px gas usage (rows 92-111)
  const gasUsed = parseInt(tx.gas, 16);
  const gasScale = gasExpScale(gasUsed, 20);
  gasScale.reverse();
  col.set(gasScale, 92);

  // 20px priority fee (rows 114-133)
  const gasPriceWei = tx.gasPrice ? parseInt(tx.gasPrice, 16) : 0;
  const effectivePriorityFee = Math.max(0, gasPriceWei - baseFeeWei);
  const priorityFeeGwei = effectivePriorityFee / 1e9;
  const chain = getActiveChain();
  const pfScale = priorityFeeExpScale(priorityFeeGwei, 20, chain.tipMin, chain.tipMax);
  pfScale.reverse();
  col.set(pfScale, 114);

  return col;
}

function fourByteColor(v) {
  if (v < 85) {
    return [0, 0, Math.round((v / 84) * 255)];
  } else if (v < 170) {
    return [Math.round(((v - 85) / 84) * 255), 0, 255];
  } else {
    return [255, Math.round(((v - 170) / 85) * 255), 255];
  }
}

// --- Rendering ---

function tintColor(r, g, b, chainColor) {
  const [cr, cg, cb] = chainColor;
  return [
    Math.round(r * cr / 255),
    Math.round(g * cg / 255),
    Math.round(b * cb / 255),
  ];
}

function wouldBlockOverflow(txCount) {
  const logicalWidth = canvas.clientWidth;
  const logicalHeight = canvas.clientHeight;
  let simX = cursorX;
  let simY = cursorY;

  for (let i = 0; i < txCount; i++) {
    if (simX + COL_WIDTH > logicalWidth) {
      simX = 0;
      simY += ROW_SPACING;
    }
    if (simY + COL_HEIGHT > logicalHeight) {
      return true;
    }
    simX += COL_WIDTH;
  }

  return false;
}

function resetPage() {
  const logicalWidth = canvas.clientWidth;
  const logicalHeight = canvas.clientHeight;
  ctx.clearRect(0, 0, logicalWidth, logicalHeight);
  cursorX = 0;
  cursorY = 0;
  clearStoredData();
}

function drawColumn(col, tx, blockNum, baseFeeWei) {
  const logicalWidth = canvas.clientWidth;
  const chainColor = getActiveChain().color;

  if (cursorX + COL_WIDTH > logicalWidth) {
    cursorX = 0;
    cursorY += ROW_SPACING;
  }

  txHitmap.push({ x: cursorX, y: cursorY, tx, blockNum, col: col.slice(), baseFeeWei });

  const gasPriceWei = tx.gasPrice ? parseInt(tx.gasPrice, 16) : 0;
  const effectivePriority = gasPriceWei - baseFeeWei;
  const lowPriorityFee = effectivePriority < getActiveChain().lowTip * 1e9;

  const dpr = window.devicePixelRatio || 1;
  const pxW = Math.round(COL_WIDTH * dpr);
  const pxH = Math.round(COL_HEIGHT * dpr);
  const imgData = ctx.createImageData(pxW, pxH);
  const data = imgData.data;

  for (let y = 0; y < COL_HEIGHT; y++) {
    const isBoundary = BOUNDARY_ROWS.includes(y);
    const yStart = Math.round(y * dpr);
    const yEnd = Math.round((y + 1) * dpr);
    for (let row = yStart; row < yEnd; row++) {
      for (let x = 0; x < pxW; x++) {
        const i = (row * pxW + x) * 4;
        if (isBoundary) {
          data[i] = 0;
          data[i + 1] = 0;
          data[i + 2] = 0;
        } else if (y >= FOUR_BYTE_START && y <= FOUR_BYTE_END) {
          const [r, g, b] = fourByteColor(col[y]);
          const [tr, tg, tb] = tintColor(r, g, b, chainColor);
          data[i] = tr;
          data[i + 1] = tg;
          data[i + 2] = tb;
        } else if (y >= 92 && lowPriorityFee) {
          const v = col[y];
          const r = Math.round(v * 110 / 255);
          const g = Math.round(v * 84 / 255);
          const b = v;
          const [tr, tg, tb] = tintColor(r, g, b, chainColor);
          data[i] = tr;
          data[i + 1] = tg;
          data[i + 2] = tb;
        } else {
          const v = col[y];
          const [tr, tg, tb] = tintColor(v, v, v, chainColor);
          data[i] = tr;
          data[i + 1] = tg;
          data[i + 2] = tb;
        }
        data[i + 3] = 255;
      }
    }
  }

  ctx.putImageData(imgData, Math.round(cursorX * dpr), Math.round(cursorY * dpr));
  cursorX += COL_WIDTH;
}

function addBlockGap() {
  cursorX += BLOCK_GAP;
}

// --- Indicator dots ---

function flashDot(chainKey) {
  const dot = document.getElementById("dot-" + chainKey);
  if (!dot) return;
  const chain = CHAINS[chainKey];
  const [r, g, b] = chain.color;
  dot.style.background = `rgb(${r},${g},${b})`;
  clearTimeout(dotFlashTimeouts[chainKey]);
  dotFlashTimeouts[chainKey] = setTimeout(() => {
    dot.style.background = "#333";
  }, 200);
}

function startDotInterval(chainKey) {
  stopDotInterval(chainKey);
  const chain = CHAINS[chainKey];
  dotIntervals[chainKey] = setInterval(() => {
    flashDot(chainKey);
  }, chain.blockTime);
}

function stopDotInterval(chainKey) {
  if (dotIntervals[chainKey]) {
    clearInterval(dotIntervals[chainKey]);
    delete dotIntervals[chainKey];
  }
}

function initDotIntervals() {
  for (const key of Object.keys(CHAINS)) {
    if (key !== activeChainKey) {
      startDotInterval(key);
    }
  }
}

// --- Main loop ---

async function processBlock(blockNum) {
  const block = await getBlockByNumber(blockNum);
  if (!block) return false;

  const txCount = block.transactions ? block.transactions.length : 0;

  blockData[blockNum] = {
    number: blockNum,
    hash: block.hash,
    timestamp: parseInt(block.timestamp, 16),
    baseFeePerGas: block.baseFeePerGas || null,
    txCount,
  };

  const baseFeeWei = block.baseFeePerGas ? parseInt(block.baseFeePerGas, 16) : 0;

  if (block.transactions && block.transactions.length > 0) {
    if (wouldBlockOverflow(block.transactions.length)) {
      resetPage();
    }
    for (const tx of block.transactions) {
      const col = buildColumn(tx, baseFeeWei);
      drawColumn(col, tx, blockNum, baseFeeWei);
    }
  }

  addBlockGap();

  // Flash the selected chain's dot on real block arrival
  flashDot(activeChainKey);

  return true;
}

async function start() {
  nextBlockNum = await getLatestBlockNumber();
  poll();
}

async function poll() {
  try {
    const chainKeyAtStart = activeChainKey;
    const success = await processBlock(nextBlockNum);
    // If user switched chains while we were fetching, bail out
    if (activeChainKey !== chainKeyAtStart) return;
    if (success) {
      nextBlockNum++;
    }
    pollTimeoutId = setTimeout(poll, getActiveChain().pollInterval);
  } catch (e) {
    if (activeChainKey) {
      pollTimeoutId = setTimeout(poll, getActiveChain().pollInterval);
    }
  }
}

function stopPolling() {
  if (pollTimeoutId) {
    clearTimeout(pollTimeoutId);
    pollTimeoutId = null;
  }
}

// --- Chain switching ---

function switchChain(newChainKey) {
  if (newChainKey === activeChainKey) return;

  const prevChainKey = activeChainKey;

  // Stop current polling
  stopPolling();

  // Clear canvas and state
  const logicalWidth = canvas.clientWidth;
  const logicalHeight = canvas.clientHeight;
  ctx.clearRect(0, 0, logicalWidth, logicalHeight);
  cursorX = 0;
  cursorY = 0;
  clearStoredData();
  nextBlockNum = null;

  // Update active chain
  activeChainKey = newChainKey;

  // Update URL hash
  history.replaceState(null, "", "#" + newChainKey);

  // Update button styles
  document.querySelectorAll(".chain-btn").forEach(btn => {
    btn.classList.toggle("active", btn.dataset.chain === newChainKey);
  });

  // Dot intervals: start interval for previously-selected, stop for newly-selected
  startDotInterval(prevChainKey);
  stopDotInterval(newChainKey);

  // Start fetching new chain
  start();
}

// --- Tooltip / hover ---

function findTxAt(mx, my) {
  for (let i = txHitmap.length - 1; i >= 0; i--) {
    const h = txHitmap[i];
    // Adjust my for header offset: mouse coords are page-relative,
    // but hit positions are canvas-relative
    const canvasY = my - HEADER_HEIGHT;
    if (mx >= h.x && mx < h.x + COL_WIDTH && canvasY >= h.y && canvasY < h.y + COL_HEIGHT) {
      return h;
    }
  }
  return null;
}

function formatEth(hexWei) {
  const wei = BigInt(hexWei);
  const eth = Number(wei) / 1e18;
  if (eth === 0) return "0";
  if (eth < 0.0001) return eth.toExponential(2);
  if (eth >= 1000) return Math.round(eth).toLocaleString();
  return eth.toFixed(6);
}

function formatGwei(hexWei) {
  if (!hexWei) return null;
  const wei = BigInt(hexWei);
  const gwei = Number(wei) / 1e9;
  if (gwei === 0) return "0";
  if (gwei < 0.001) return gwei.toExponential(2);
  if (gwei >= 1000) return gwei.toFixed(0);
  return gwei.toFixed(3);
}

function formatGweiNum(gwei) {
  if (gwei === 0) return "0";
  if (gwei < 0.001) return gwei.toExponential(2);
  if (gwei >= 1000) return gwei.toFixed(0);
  return gwei.toFixed(3);
}

function renderVerticalBar(sliceData, w, h, colorFn) {
  const c = document.createElement('canvas');
  c.className = 'tt-bar';
  c.width = w;
  c.height = h;
  c.style.width = w + 'px';
  c.style.height = h + 'px';
  const cx = c.getContext('2d');
  const rowH = h / sliceData.length;
  for (let i = 0; i < sliceData.length; i++) {
    const [r, g, b] = colorFn(sliceData[i]);
    cx.fillStyle = `rgb(${r},${g},${b})`;
    cx.fillRect(0, Math.round(i * rowH), w, Math.ceil(rowH));
  }
  return c;
}

function renderAddressPattern(addrSlice, w, h, chainColor) {
  const c = document.createElement('canvas');
  c.className = 'tt-addr-pattern';
  c.width = w;
  c.height = h;
  c.style.width = w + 'px';
  c.style.height = h + 'px';
  const cx = c.getContext('2d');
  const rowH = h / addrSlice.length;
  for (let i = 0; i < addrSlice.length; i++) {
    const v = addrSlice[i];
    const [r, g, b] = tintColor(v, v, v, chainColor);
    cx.fillStyle = `rgb(${r},${g},${b})`;
    cx.fillRect(0, Math.round(i * rowH), w, Math.ceil(rowH));
  }
  return c;
}

function ttItem(value, unit, label) {
  const item = document.createElement('div');
  item.className = 'tt-item';
  const valEl = document.createElement('div');
  valEl.className = 'tt-value';
  valEl.textContent = unit ? value + ' ' + unit : value;
  item.appendChild(valEl);
  const lblEl = document.createElement('div');
  lblEl.className = 'tt-label';
  lblEl.textContent = label;
  item.appendChild(lblEl);
  return item;
}

function hideTooltip() {
  tooltipEl.style.display = "none";
  tooltipEl.style.pointerEvents = "none";
  tooltipEl.onmouseleave = null;
}

function showTooltip(hit, mouseX, mouseY) {
  const chain = getActiveChain();
  const tx = hit.tx;
  const blk = blockData[hit.blockNum];
  const col = hit.col;
  const baseFeeWei = hit.baseFeeWei;
  const chainColor = chain.color;
  const inputLen = tx.input && tx.input !== "0x" ? (tx.input.length - 2) / 2 : 0;
  const scanUrl = chain.explorerUrl + tx.hash;

  const gasPriceWei = tx.gasPrice ? parseInt(tx.gasPrice, 16) : 0;
  const effectivePriorityFee = Math.max(0, gasPriceWei - baseFeeWei);
  const lowPriorityFee = effectivePriorityFee < chain.lowTip * 1e9;

  function gasColorFn(v) {
    if (lowPriorityFee && v > 0) {
      const r = Math.round(v * 110 / 255);
      const g = Math.round(v * 84 / 255);
      return tintColor(r, g, v, chainColor);
    }
    return tintColor(v, v, v, chainColor);
  }
  function normalColorFn(v) {
    return tintColor(v, v, v, chainColor);
  }

  const pfSlice = col.slice(114, 134).reverse();
  const gasSlice = col.slice(92, 112).reverse();
  const lenSlice = col.slice(70, 90);
  const fromSlice = col.slice(0, 20);
  const toSlice = col.slice(22, 42);

  const BAR_W = 10;
  const BAR_H = 140;

  tooltipEl.replaceChildren();

  // --- Upper section ---
  const upper = document.createElement('div');
  upper.className = 'tt-upper';

  // Column 1: Priority fee bar + fee numbers
  const col1 = document.createElement('div');
  col1.className = 'tt-col';
  const feeSection = document.createElement('div');
  feeSection.className = 'tt-section';
  feeSection.appendChild(ttItem(parseInt(tx.gas, 16).toLocaleString(), '', 'gas used'));
  if (tx.maxPriorityFeePerGas) {
    feeSection.appendChild(ttItem(formatGwei(tx.maxPriorityFeePerGas), '', 'tip'));
  } else if (gasPriceWei && baseFeeWei) {
    feeSection.appendChild(ttItem(formatGweiNum(effectivePriorityFee / 1e9), '', 'tip'));
  }
  if (blk && blk.baseFeePerGas) {
    feeSection.appendChild(ttItem(formatGwei(blk.baseFeePerGas), '', 'base fee'));
  }
  if (tx.maxFeePerGas) {
    feeSection.appendChild(ttItem(formatGwei(tx.maxFeePerGas), '', 'max fee'));
  }
  col1.appendChild(renderVerticalBar(pfSlice, BAR_W, BAR_H, gasColorFn));
  col1.appendChild(feeSection);
  upper.appendChild(col1);

  // Column 2: Gas bar + data info
  const col2 = document.createElement('div');
  col2.className = 'tt-col';
  const dataSection = document.createElement('div');
  dataSection.className = 'tt-section';
  if (inputLen >= 4) {
    dataSection.appendChild(ttItem(tx.input.slice(0, 10), '', 'selector'));
  }
  dataSection.appendChild(ttItem(inputLen.toLocaleString(), '', 'input bytes'));
  const spacer = document.createElement('div');
  spacer.className = 'tt-spacer';
  dataSection.appendChild(spacer);
  dataSection.appendChild(ttItem(formatEth(tx.value), chain.currency, 'value'));
  col2.appendChild(renderVerticalBar(gasSlice, BAR_W, BAR_H, gasColorFn));
  col2.appendChild(dataSection);
  upper.appendChild(col2);

  // Column 3: Input length bar + block info
  const col3 = document.createElement('div');
  col3.className = 'tt-col';
  const blockSection = document.createElement('div');
  blockSection.className = 'tt-section';
  blockSection.appendChild(ttItem(hit.blockNum.toLocaleString(), '', 'block'));
  if (blk) {
    const date = new Date(blk.timestamp * 1000);
    blockSection.appendChild(ttItem(date.toTimeString().slice(0, 8), '', 'time'));
    blockSection.appendChild(ttItem(
      date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }), '', 'date'));
  }
  col3.appendChild(renderVerticalBar(lenSlice, BAR_W, BAR_H, normalColorFn));
  col3.appendChild(blockSection);
  upper.appendChild(col3);

  tooltipEl.appendChild(upper);

  // --- Bottom section ---
  const bottom = document.createElement('div');
  bottom.className = 'tt-bottom';

  const fromRow = document.createElement('div');
  fromRow.className = 'tt-addr-row';
  fromRow.appendChild(renderAddressPattern(fromSlice, BAR_W, 20, chainColor));
  const fromAddr = document.createElement('span');
  fromAddr.className = 'tt-addr';
  fromAddr.textContent = tx.from;
  fromRow.appendChild(fromAddr);
  const fromLbl = document.createElement('span');
  fromLbl.className = 'tt-addr-label';
  fromLbl.textContent = 'from';
  fromRow.appendChild(fromLbl);
  bottom.appendChild(fromRow);

  const toRow = document.createElement('div');
  toRow.className = 'tt-addr-row';
  toRow.appendChild(renderAddressPattern(toSlice, BAR_W, 20, chainColor));
  const toAddr = document.createElement('span');
  toAddr.className = 'tt-addr';
  toAddr.textContent = tx.to || '(contract creation)';
  toRow.appendChild(toAddr);
  const toLbl = document.createElement('span');
  toLbl.className = 'tt-addr-label';
  toLbl.textContent = 'to';
  toRow.appendChild(toLbl);
  bottom.appendChild(toRow);

  tooltipEl.appendChild(bottom);

  // Hash footer
  const hashBar = document.createElement('div');
  hashBar.className = 'tt-hash-bar';
  const hashLink = document.createElement('a');
  hashLink.href = scanUrl;
  hashLink.target = '_blank';
  hashLink.rel = 'noopener';
  hashLink.textContent = tx.hash;
  hashBar.appendChild(hashLink);
  tooltipEl.appendChild(hashBar);

  // --- Position ---
  tooltipEl.style.display = 'block';
  tooltipEl.style.left = '0px';
  tooltipEl.style.top = '0px';
  tooltipEl.style.pointerEvents = tooltipLocked ? 'auto' : 'none';

  const rect = tooltipEl.getBoundingClientRect();
  const pageW = window.innerWidth;
  const pageH = window.innerHeight;

  let left = mouseX - rect.width / 2;
  left = Math.max(8, Math.min(left, pageW - rect.width - 8));

  const txScreenY = hit.y + HEADER_HEIGHT;
  const txMidY = txScreenY + COL_HEIGHT / 2;
  let top;
  if (txMidY < pageH / 2) {
    top = txScreenY + COL_HEIGHT + 8;
  } else {
    top = txScreenY - rect.height - 8;
  }
  top = Math.max(HEADER_HEIGHT + 4, Math.min(top, pageH - rect.height - 4));

  tooltipEl.style.left = left + 'px';
  tooltipEl.style.top = top + 'px';

  tooltipEl.onmouseleave = () => {
    if (tooltipLocked) {
      tooltipLocked = false;
      tooltipEl.style.pointerEvents = 'none';
      hideTooltip();
    }
  };
}

canvas.addEventListener("mousemove", (e) => {
  if (tooltipLocked) return;
  const mx = e.clientX;
  const my = e.clientY;
  const hit = findTxAt(mx, my);
  if (hit) {
    if (lastHit && lastHit.tx.hash === hit.tx.hash) return;
    lastHit = hit;
    showTooltip(hit, mx, my);
  } else {
    if (lastHit) {
      lastHit = null;
      hideTooltip();
    }
  }
});

canvas.addEventListener("click", (e) => {
  const mx = e.clientX;
  const my = e.clientY;
  const hit = findTxAt(mx, my);
  if (hit) {
    tooltipLocked = true;
    showTooltip(hit, mx, my);
  } else {
    tooltipLocked = false;
    hideTooltip();
  }
});

document.addEventListener("mousedown", (e) => {
  if (tooltipLocked && !tooltipEl.contains(e.target) && e.target !== canvas) {
    tooltipLocked = false;
    hideTooltip();
  }
});

// --- Button click handlers ---

document.querySelectorAll(".chain-btn").forEach(btn => {
  btn.addEventListener("click", () => {
    switchChain(btn.dataset.chain);
  });
});

// --- Hash-based chain selection ---

function getChainFromHash() {
  const hash = location.hash.slice(1).toLowerCase();
  return CHAINS[hash] ? hash : null;
}

window.addEventListener("hashchange", () => {
  const chainKey = getChainFromHash();
  if (chainKey) switchChain(chainKey);
});

// --- Init ---

const initialChain = getChainFromHash();
if (initialChain && initialChain !== activeChainKey) {
  activeChainKey = initialChain;
  document.querySelectorAll(".chain-btn").forEach(btn => {
    btn.classList.toggle("active", btn.dataset.chain === initialChain);
  });
}
if (!location.hash) {
  history.replaceState(null, "", "#" + activeChainKey);
}

initDotIntervals();
start();

</script>
</body>
</html>
